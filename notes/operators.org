Game plan for *incrementally* generalizing operators.  Goals:

- Support writing things like _+_ so operators parse as independent
  terms, so they can be used as arguments to higher-order functions,
  partially applied, etc.

- Simplify representation & type checking so we no longer have special
  TBin and TUn nodes, just application.

- Ultimately I want to do this now (as opposed to waiting until later)
  because I want to be able to define infix operators like 'union',
  'intersection', etc. in a library (in terms of the 'merge' prim).

I tried to do it all at once and failed; once I finally got it to
compile there were tons of errors in the test suite etc. and I was
completely at a loss as to what was going on.  This time I think I
will try a more incremental approach, i.e. try to keep it building and
passing tests as much as possible.

- Leave TBin, TUn intact at first
- [X] Add operators as prims
- [-] Add parsing rules for standalone operators & test parsing

  Have to be very careful here, parsing is tricky!
  - [X] Disallow underscores in normal variable names.
  - [ ] Try parsing each operator with underscores in the appropriate places
  - For now don't try parsing user-defined operator names; we can add
    that later.

  - OK, actually this really doesn't work well at all.  e.g.

    not_

    parses as an expression, consisting of the application of the
    operator not to a wildcard.  This is part of the reason that Idris
    requires spaces around operators!

    Maybe we need a different syntax for argument slots....  maybe
    tildes?  Don't currently use those for anything...

    not~   ~+~  ~!  etc.  I think I like it.

    OR if we wanted to be really radical we could use ~ as the wildcard
    pattern, and _ for argument slots...

    For now let's go with ~ for argument slots.  We can always change
    it later pretty easily; this way we don't have to update all the
    examples and tests that already use _ as a wildcard.

    Note this means we can also re-allow _ in variable names.

    OK, not~ still isn't parsing.  parseAtom successfully parses it;
    the problem is that when parseExpr is called, it successfully
    parses the 'not' as an operator and then tries to parse the ~ as
    an expression. Maybe just add some 'notFollowedBy' nonsense to
    operator parsing??  This is getting rather complicated.  But maybe
    that's just how it is when you have infix operators.

    Actually the fix was very easy: put ~ *back into* opChars, because
    the only place opChars is used is in reservedOp, to make sure that
    none of them come after a parsed operator name.

    Prefix ops work now.  But infix don't yet.  Ah, just needed to add
    some 'try', since it tried parsing ~+~ as some postfix thing and
    consumed the ~.  Next step: improve it so it consumes ~ first and
    then tries parsing either a postfix thing or an infix thing
    followed by ~.

- [ ] Add typing rule for one standalone operator (e.g. _+_) and get it to typecheck
- [ ] Add desugaring and compilation rules for _+_
- [ ] Switch parsing of normal infix + to produce TApp node

- Then convert other operators

